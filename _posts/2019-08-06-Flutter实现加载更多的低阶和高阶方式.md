---
layout:     post
title:      Flutter实现加载更多的低阶和高阶方式
subtitle:   通过对基础组件的封装学习Flutter高阶组件是如何产出的
date:       2019-08-06
author:     Tristan
header-img: img/post-bg-flutter-loadmore.jpeg
catalog: true
tags:
    - Flutter
    - 加载更多
    
---

<div style="text-align: center;"><img src="../../../../img/post-flutter-loadmore-1.gif" width="50%" style="display: inline-block; border: 2px solid #000000; margin: 0; padding: 0;"/></div>

## 基础方式
Flutter关于加载更多最基本也是最简单的一种实现方式是：**判断当ListView的构造器在开始构造最后一条布局的时候，将此布局替换为“加载更多”的布局**。

首先，需要在原来的列表的item的数量上加1，为最后一项“加载更多”留个位置。

当列表滑到底部，此时“加载更多”的布局相继显示，这里就有了“加载更多”；但是这里只是完成了第一步工作，因为真正加载更多数据的能力还没有的。

接下来，还需要在构造“加载更多”布局时，触发加载更多的数据方法。

注意，加载更多的方法不能即可生效，因为这里涉及到一个知识点，正在页面渲染时不能触及页面计算，所以此时还不能直接调用setState()用于加载更多，但我们可以通过延时等待页面渲染完成后再去操作。

这样，一个最基本的加载更多就实现了。这是一般加载更多的实现方式，也是native端如RecyclerView惯用的一种方式。这种方式可以实现功能，但是并不优雅，复用性不强。

```
class _MyHomePageState extends State<MyHomePage> {

  var count = 10;

  void loadMore() {
    Future.delayed(Duration(seconds: 2), () {
      setState(() {
        count += 10;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Container(
        child: ListView.builder(
          itemCount: count + 1,
          itemBuilder: _buildItem,
        ),
      ),
    );
  }

  Widget _buildItem(BuildContext context, int index) {
    if (index == count) {
      loadMore();
      return Container(
        width: MediaQuery.of(context).size.width,
        height: 80,
        child: Center(child: Text('正在加载...'),),
      );
    }
    return Container(
      width: MediaQuery.of(context).size.width,
      height: 80,
      child: Center(child: Text(index.toString())),
      decoration: BoxDecoration(
          border: Border(bottom: BorderSide(width: 1, color: Colors.white))
      ),
    );
  }

}
```

总结下来，实现一个加载更多的功能主要涵盖三步：
1. 构造列表底部加载更多的布局
2. 给加载更多留出一个占位数
3. 实现加载更多数据的逻辑

## 高阶方式
下面先列出高阶组件的使用demo，可以和上面的实现方式在使用上做下对比。

```
class _MyHomePageState2 extends State<MyHomePage> {

  var count = 10;

  Future<bool> loadMore() async {
    await Future.delayed(Duration(seconds: 2), () {
      setState(() {
        count += 10;
      });
    });
    return true;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Container(
        child: LoadMore(
          child: ListView.builder(
            itemCount: count,
            itemBuilder: _buildItem,
          ),
          onLoadMore: loadMore,
          isNoMoreData: false,
        ),
      ),
    );
  }

  Widget _buildItem(BuildContext context, int index) {
    return Container(
      width: MediaQuery.of(context).size.width,
      height: 80,
      child: Center(child: Text(index.toString())),
      decoration: BoxDecoration(
        border: Border(bottom: BorderSide(width: 1, color: Colors.white))
      ),
    );
  }

}
```

以上demo对比可以看出，使用低阶组件开发列表加载更多的需求和使用高阶组件开发的区别在于，开发者是否都需要关注到以上三个步骤？

| 组件类型 | 第1步 | 第2步 | 第3步 |
| :---: | :---: | :---: | :---: |
| 低阶组件 |   ✔️  |   ✔️  |   ✔️  |
| 高阶组件 |   -  |   -  |   ✔️  |

高阶组件已经为开发者做好了前两步的工作，并将这两步逻辑完全封装了起来，与原生组件在层级上完全隔离，不依赖具体原生组件的实现，充分做到了可复用；同时提供了最简洁的接口使用，易读性和易用性都很强。

[demo](https://github.com/tristanzeng/load_more_demo)
