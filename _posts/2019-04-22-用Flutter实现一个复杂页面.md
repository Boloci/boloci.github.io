---
layout:     post
title:      用Flutter实现一个复杂页面
subtitle:   Flutter从入门到放弃
date:       2019-04-22
author:     Tristan
header-img: img/post-bg-flutter.png
catalog: true
tags:
    - Flutter
    - 首页
    
---

## 背景
Flutter作为全新跨平台应用框架，在页面渲染和MD开发上优势明显，可谓是业界一枝独秀。正好最近有这样的一个机会学习Flutter开发，我们便尝试用它开发一个MD风格的复杂页面，来比较跟原生应用开发的优势。也是想通过对新框架的学习探索，找到适合自身应用的框架。

## 页面展示
首页是整个应用里边交互最为复杂的一个页面了，它集合了各种滑动方式，包括：`纵向滑动、横向滑动、嵌套滑动`；同时，也集合了各种动效，包括：`下拉刷新、上拉加载、头图视差、二级吸顶、回到顶部、横向Banner和纵向News轮播`等。
<div style="color: #f00;"><img src="../../../../img/post-flutter-1.jpeg" width="33%" style="display: inline-block; border: 2px solid #000000; margin: 0; padding: 0;"/><img src="../../../../img/post-flutter-2.jpeg" width="33%" style="display: inline-block; border: 2px solid #000000; margin: 0; padding: 0; margin-left: 0.5%; margin-right: 0.5%;"/><img src="../../../../img/post-flutter-3.jpeg" width="33%" style="display: inline-block; border: 2px solid #000000; margin: 0; padding: 0;"></div>

## 开发历程
- 搭建了开发环境，新建flutter module并学习dart语法
- 调研用Flutter实现`CoordinatorLayout`的方案
- 实现了首页`主框架`的demo搭建，目前同样遇到了滑动冲突的问题，在调研解决方案
- 解决了`滑动冲突`的问题，并集成了下拉刷新能力
- 完成了各区块和feed流的`静态UI`内容，目前剩余feed流加载更多和负二楼动效
- 实现首页feed流的`加载更多`功能

## 技术难点
#### 两级吸顶
在Flutter中实现吸顶功能比较容易，使用SliverPersistentHeader控件或者间接使用该控件都可以满足吸顶的功能；更重要的是，它支持滑动过程中任意组件的吸顶，即多级吸顶功能。

既然多级吸顶都支持，那么两级吸顶就很轻松了，首页头部和feed流tab的两级吸顶是这样实现的：第一级，使用SliverAppBar（它内部就是一个SliverPersistentHeader控件），不仅可以吸顶，还带有折叠属性，折叠属性能更好的满足头部滑动时的动效处理；第二级，使用SliverPersistentHeader并自定义它的delegate，通过pinned属性灵活选择当前模块吸顶与否，这样可以实现任意组件的吸顶功能。
    
```js
SliverAppBar(
  pinned: true,
  ...,
  bottom: PreferredSize(
    child: Header(...),
    preferredSize: Size(screenWidth, 15),
  ),
),
SliverPersistentHeader(
  pinned: false,
  delegate: _SliverColumnDelegate(
    Column(...),
  )
),
SliverPersistentHeader(
  pinned: true,
  delegate: _SliverTabBarDelegate(
    TabBar(...)
  ),
),
``` 

pinned的原理很简单，将它设置为true内容到达顶部后不会再跟随外层的ScrollView继续滚动；反之，内容则会滚动出容器外。

> 而native端实现这个二级吸顶却很费力，通常你可能需要事先隐藏一个跟吸顶内容一样的驻顶view在那里，然后在页面滚动时计算吸顶内容是否已经划至顶部，维护驻顶view的可见属性达到吸顶效果。

上面粗犷的两级吸顶完成了，但想要充分满足首页的折叠效果和准确的二级吸顶需求，还得深挖一下AppBar内部的折叠计算方法。

#### SliverAppBar折叠计算
SliverAppBar通常作为页面头部使用，是会随内容一起滑动的一个组件；它的构造方法中有四个Widget类型的参数。`分析Widget类型的参数，是因为我们需要一个容器来满足自定义首页头部——它既能实现吸顶，又可以接入自定义组件。`
    
> * leading // 左侧按钮
> * title // 标题
> * flexibleSpace // 可以展开区域
> * bottom // 底部内容区域

回顾一下首页的折叠展示效果，首先排除了leading，然后title受leading占位影响宽度有限制也无法满足需要；之后，就剩下的两个参数可选了，从命名上看，感觉flexibleSpace更符合折叠效果的实现思路，然后一直在尝试使用其实现头部折叠的需求，但开发过程中发现折叠后的高度是无法达到预期的，设计比实现的要高一些。显然，使用排除法已经不好解决该问题了。想了解flexibleSpace为什么会有高度限制，必然得看一下SliverAppBar的源码实现了。

```js
class _SliverAppBarState extends State<SliverAppBar> with TickerProviderStateMixin {
  ...
  @override
  Widget build(BuildContext context) {
    assert(!widget.primary || debugCheckHasMediaQuery(context));
    final double topPadding = widget.primary ? MediaQuery.of(context).padding.top : 0.0;
    final double collapsedHeight = (widget.pinned && widget.floating && widget.bottom != null)
      ? widget.bottom.preferredSize.height + topPadding : null;

    return MediaQuery.removePadding(
      context: context,
      removeBottom: true,
      child: SliverPersistentHeader(
        floating: widget.floating,
        pinned: widget.pinned,
        delegate: _SliverAppBarDelegate(
          ...
          collapsedHeight: collapsedHeight,
          topPadding: topPadding,
        ),
      ),
    );
  }
}

```

    final double collapsedHeight = (widget.pinned && widget.floating && widget.bottom != null)
      ? widget.bottom.preferredSize.height + topPadding : null;

变量collapsedHeight代表了折叠后头部的高度，从它的计算表达式可看出：当widget.bottom == null的时候，collapsedHeight的值为null。换言之，如果不使用bottom，那么折叠高度是没有的。如果没有折叠后的高度会发生什么？这个需要进一步验证。

```js
const double kToolbarHeight = 56.0;

class _SliverAppBarDelegate extends SliverPersistentHeaderDelegate {
    ...
    final double _bottomHeight = bottom?.preferredSize?.height ?? 0.0;
    @override
    double get minExtent => collapsedHeight ?? (topPadding + kToolbarHeight + _bottomHeight);
}
```

从上面的源码看，如果collapsedHeight == null，那么折叠后的头部高度就是topPadding + kToolbarHeight了。topPadding是系统状态栏的高度，kToolbarHeight是个自定义常量。不难看出，bottom为空时折叠头部的高度就会是一个固定高度。那么反过来，想要自定义高度，就必须的使用bottom，折叠后的头部高度完全取决于bottom的高度（一般，系统状态栏的高度是确定的）。

实现两级吸顶并明确了头部参数设置，其实整个页面框架就基本拟定了。接下来，我们细化一下，看看头部控件具体是怎么实现的。

#### 自定义头部
首页头部组件包括以下内容：
> 1. 搜索栏和城市名吸顶
> 2. 头图视差
> 3. 下拉刷新
> 4. 负二楼 // TODO

基于之前首页native端的开发经验，这些效果的实现都可以由一个变量驱动，即首页头部的纵向滑动偏移值。这个偏移值参照它的初始位置，分为上偏移和下偏移。上偏移驱动处理第一项内容，下偏移则驱动处理剩余项。而这些内容概括为一个词就是动画。

通过自定义**Header组件**来处理搜索栏和城市名吸顶的动画，其中主要是借助外部传入的`上偏移值`驱动整个动画的完成。

```js
import 'package:flutter/material.dart';
import 'package:wuba_flutter_lib/home/search_bar.dart';

const double SEARCH_MARGIN_LEFT = 15.0; // 搜索栏left居左位置

typedef OnOffsetChangeListener = Function(double percent);

class Header extends StatefulWidget {

  Header({
    Key key,
    this.offset: 0.0,
    this.cityName,
    this.onOffsetChangeListener,
  }) : super(key: key);

  final double offset;
  final String cityName;
  final OnOffsetChangeListener onOffsetChangeListener;

  double searchLeft    = SEARCH_MARGIN_LEFT;
  double searchLeftEnd = SEARCH_MARGIN_LEFT;

  @override
  State<StatefulWidget> createState() => HeaderState();
}

class HeaderState extends State<Header> with TickerProviderStateMixin {

  AnimationController searchBgColorAnimController;
  Animation<Color> searchBgColor;
  
  drive(offset) {
    // 过渡比例
    double percent = offset / 80.0 > 1.0 ? 1.0 : offset / 80.0;
    // 偏移比例回调
    if (widget.onOffsetChangeListener != null) {
      widget.onOffsetChangeListener(percent);
    }
    // 搜索栏居左吸顶后的位置
    widget.searchLeftEnd = SEARCH_MARGIN_LEFT + (widget.cityName ?? '').length * 22 + CITY_MARGIN_RIGHT;
    // 搜索栏居左位置
    widget.searchLeft = (SEARCH_MARGIN_LEFT + (widget.searchLeftEnd - SEARCH_MARGIN_LEFT) * percent);
    // 背景颜色控制
    searchBgColorAnimController.value = percent;
  }

  @override
  void didUpdateWidget(Header oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.offset != oldWidget.offset) {
      drive(widget.offset);
    }
  }

  @override
  void initState() {
    super.initState();
    searchBgColorAnimController = new AnimationController(vsync: this);
    searchBgColor = ColorTween(
      begin: Color(0xffffffff),
      end: Color(0xffDADDE1),
    ).animate(
      CurvedAnimation(
        parent: searchBgColorAnimController,
        curve: Interval(0.0, 1.0, curve: Curves.linear),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      overflow: Overflow.visible,
      children: <Widget>[
        // 搜索栏
        SearchBar(
          left: widget.searchLeft,
          bgColor: searchBgColor.value,
          ...
        ),
        ...
      ],
    );
  }

}
```

**头图视差**使用了Container的矩阵变换属性，主要是对y轴进行位移，这个位移带有视差系数。

```js
Matrix4 matrix = Matrix4.translationValues(0.0, _offset, 0.0);

Container(
  transform: matrix,
  width: screenWidth,
  height: screenWidth,
  child: Image.asset("assets/images/home_bg.jpg", fit: BoxFit.fill)
),
```
    

#### 模块自己管理

    

#### 滑动冲突

    

#### 加载更多



#### Global Keys

    

## 参考文档
