---
layout:     post
title:      TextView多行文字超出时如何在省略号后添加图标
subtitle:   TextView的图文混排知识
date:       2019-05-29
author:     Tristan
header-img: img/post-bg-textview.png
catalog: true
tags:
    - TextView
    - 图文混排
    - 富文本
    - Android
    
---

## 背景
最近在做feed流模板样式调整时，出现了这样一个需求，要求在标题**文字后面**（不是控件后面）加一个图片标签来展示精帖。标题文字控制最大显示两行，文字超出部分用省略号代替，图标紧跟在文字或是省略号后显示。
<div style="text-align: center;"><img src="../../../../img/post-textview-1.png" width="80%" style="display: inline-block; border: 2px solid #000000; margin: 0; padding: 0;"/></div>

## 技术点
#### 图文混排方案
Android官方对TextView的图文混排提供了支持，我们可以从以下三种方案实现TextView的图文混排：
> 1. 在TextView中使用Compound Drawable属性；<br/>
> 2. 在TextView中显示HTML文本；<br/>
> 3. 在TextView中使用Spannable多样式显示。<br/>

`方案1`实现效果其实跟在控件后面（周围）加图片标签的性质是一样的，**文字多行显示时无法满足图标紧跟文字显示的需求**，单行标题的模板可以使用此方案。

`方案2`是通过将HTML内容转化为Spanned格式在TextView中进行显示，它的输出是SpannableStringBuilder，实现原理跟`方案3`一样。它有特定的应用场景，所以此处不做过多描述，列出核心源码便可以理解。
```java
public Spanned convert() {

    mReader.setContentHandler(this);
    try {
        mReader.parse(new InputSource(new StringReader(mSource)));
    } catch (IOException e) {
        // We are reading from a string. There should not be IO problems.
        throw new RuntimeException(e);
    } catch (SAXException e) {
        // TagSoup doesn't throw parse exceptions.
        throw new RuntimeException(e);
    }

    // Fix flags and range for paragraph-type markup.
    Object[] obj = mSpannableStringBuilder.getSpans(0, mSpannableStringBuilder.length(), ParagraphStyle.class);
    for (int i = 0; i < obj.length; i++) {
        int start = mSpannableStringBuilder.getSpanStart(obj[i]);
        int end = mSpannableStringBuilder.getSpanEnd(obj[i]);

        // If the last line of the range is blank, back off by one.
        if (end - 2 >= 0) {
            if (mSpannableStringBuilder.charAt(end - 1) == '\n' &&
                mSpannableStringBuilder.charAt(end - 2) == '\n') {
                end--;
            }
        }

        if (end == start) {
            mSpannableStringBuilder.removeSpan(obj[i]);
        } else {
            mSpannableStringBuilder.setSpan(obj[i], start, end, Spannable.SPAN_PARAGRAPH);
        }
    }

    return mSpannableStringBuilder;
}
```

`方案3`的输出格式是SpannableString，它和`方案2`的SpannableStringBuilder都实现了CharSequence接口，TextView的setText()方法传入参数其实就是这个接口类型；同时它们又都实现了Spannable接口，Spannable的setSpan()方法定义了如何编辑字符串，通过它可以设置一些格式对象（例如字体、颜色、图片、点击事件等），这样就实现富文本显示了。
<div style="text-align: center;"><img src="../../../../img/post-textview-2.png" width="100%" style="display: inline-block; border: 2px solid #000000; margin: 0; padding: 0;"/></div>

`SpannableString`和`SpannableStringBuilder`的区别就好比String和StringBuilder，前者在创建的时候就需要指定好字符串，之后就不能更改了，而后者可以使用append()方法，在已有的富文本后添加新的富文本。

#### 图文混排实现
图片替换指定文本实现图文混排的逻辑还是比较简单的：创建一个SpannableString对象，将文本传入，然后把文本中的占位符通过图片样式ImageSpan替换即可。以下是具体的逻辑实现：
```java
String text = guessLikeBean.getTitle()+"(精)";// 标题文本，通过"(精)"占位
...
SpannableString imageString = new SpannableString(text);// 创建SpannableString对象
Drawable image = mContext.getResources().getDrawable(R.drawable.ic_recommend_job_jing2);// 获取图片资源
ImageSpan imageSpan = new ImageSpan(image);// 图片样式
imageString.setSpan(imageSpan, imageString.length()-3, imageString.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);// 图片替换占位符
mTvTitle.setText(imageString);// 给TextView设置图文
```

SpannableString的setSpan()方法参数解释：

    void setSpan(Object what, int start, int end, int flags)
    
| 参数 | 说明 |
| --- | --- |
| what| 样式对象 |
| start| 样式开始的字符索引 |
| end  | 样式结束的字符索引 |
| flags| 新插入字符的设置 |

这样简单的图文混排就已经实现了；但是存在一个问题：**如果文本过长，末尾的图标同样和文字一样也会被省略号替代**。图标紧跟省略号显示的需求此时还不能满足。

#### 富文本原理
SpannableString
```java
private String mText;
private Object[] mSpans;
private int[] mSpanData;
private int mSpanCount;

private static final int START = 0;
private static final int END = 1;
private static final int FLAGS = 2;
private static final int COLUMNS = 3;

void setSpan(Object what, int start, int end, int flags) {
    ...
    mSpans[mSpanCount] = what;
    mSpanData[mSpanCount * COLUMNS + START] = start;
    mSpanData[mSpanCount * COLUMNS + END] = end;
    mSpanData[mSpanCount * COLUMNS + FLAGS] = flags;
    mSpanCount++;
}
```

#### Layout属性
TextView的Layout属性管理了文本的布局展示，同时也提供了两个能力，
> 1. 获取省略号在当前行的开始位置；
> 2. 获取当前行内被省略文字的长度。

```java
/**
 * Return the offset of the first character to be ellipsized away,
 * relative to the start of the line.  (So 0 if the beginning of the
 * line is ellipsized, not getLineStart().)
 */
public abstract int getEllipsisStart(int line);

/**
 * Returns the number of characters to be ellipsized away, or 0 if
 * no ellipsis is to take place.
 */
public abstract int getEllipsisCount(int line);
```

有了以上能力，针对上文最后提到的问题马上便会有思路：**通过精确计算被省略的文字位置，截取字符串重新插入占位标识符，然后实现在省略号处添加图片**，以确保“精”字图标不会因文字超出而被省略。
```java
String text = guessLikeBean.getTitle()+"(精)";
mTvTitle.setText(text);
int ellipsisCount = mTvTitle.getLayout().getEllipsisCount(mTvTitle.getLineCount() - 1);
if (ellipsisCount > 0) {
    text = text.substring(0, text.length() - ellipsisCount - 1) + "…(精)";
}
SpannableString imageString = new SpannableString(text);
...
```

#### Drawble属性
**Drawble如果不设置Bounds属性，图片无法被绘制，如上占位符的地方显示的便是空白**。

Drawble设置Bounds属性的方法如下：
```java
public void setBounds(int left, int top, int right, int bottom);

public void setBounds(Rect bounds);
```
setBounds()主要设置绘制区域矩形的边界，draw()方法在绘制图片时会用到Bounds属性值，不设置默认边界均为0，所以使用Drawable时必须先设置这个属性。

标题的字体大小是17sp，因此将bounds的属性分别设置为：左，0dp；上，0dp；右，17dp；下，17dp。实现后的效果如下，发现图片在行内没有垂直居中显示，这一点达不到预期效果。
<div style="text-align: center;"><img src="../../../../img/post-textview-4.jpeg" width="80%" style="display: inline-block; border: 2px solid #000000; margin: 0; padding: 0;"/></div>

之后尝试修改参数，将top值改为负数，试图把图片的上边界向上扩展，但结果也都不达预期。
```java
int left   = DensityUtil.dip2px(mContext, 1);
int top    = DensityUtil.dip2px(mContext, -1);
int right  = DensityUtil.dip2px(mContext, 16);
int bottom = DensityUtil.dip2px(mContext, 17);

image.setBounds(left, top, right, bottom);
```

仔细考虑，可能是因为图片本身的尺寸比例是正方形，意图单纯通过修改上下边界参数无法做到图片垂直居中。最后，跳出单纯修改参数的思维，同时修改了图片的画布大小，在保留原始图片的基础上在其下方留白，然后配合以上边界值参数，最终得到了向好的结果。
<div style="text-align: center;"><img src="../../../../img/post-textview-3.png" width="20%" style="display: inline-block; border: 2px solid #000000; margin: 0; padding: 0;"/></div>

#### 开发技巧
Layout中有大量的计算逻辑，它是异步执行的；在TextView还没有计算出它的高度前冒然调用layout的方法必然会发生奔溃现象。View的post()方法可以保证新任务是在layout调用过后执行，此处可以通过此方法避免该问题。
```java
mTvTitle.post(new Runnable() {
    @Override
    public void run() {
        int ellipsisCount = mTvTitle.getLayout().getEllipsisCount(mTvTitle.getLineCount() - 1);
        ...
        mTvTitle.setText(imageString);
    }
});
```

最后列出完整的代码实现供审阅。
```java
mTvTitle.post(new Runnable() {
    @Override
    public void run() {
        // 计算文字超出部分做精确截取
        String text = guessLikeBean.getTitle()+"(精)";
        mTvTitle.setText(text);
        int ellipsisCount = mTvTitle.getLayout().getEllipsisCount(mTvTitle.getLineCount() - 1);
        if (ellipsisCount > 0) {
            text = text.substring(0, text.length() - ellipsisCount - 1) + "…(精)";
        }
        
        // 创建SpannableString对象
        SpannableString imageString = new SpannableString(text);
        
        // 获取图片资源并设置绘制边界
        Drawable image = mContext.getResources().getDrawable(R.drawable.ic_recommend_job_jing2);
        int left = DensityUtil.dip2px(mContext, 1);
        int top = DensityUtil.dip2px(mContext, -1);
        int right = DensityUtil.dip2px(mContext, 16);
        int bottom = DensityUtil.dip2px(mContext, 17);
        image.setBounds(left, top, right, bottom);
        
        // 创建图片样式对象替换占位符
        ImageSpan imageSpan = new ImageSpan(image);
        imageString.setSpan(imageSpan, imageString.length()-3, imageString.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);
        mTvTitle.setText(imageString);
    }
});
```

## 文献
[Android图文混排实现方式详解](https://juejin.im/post/59a75a50518825241e22394d#heading-7)<br/>
[Android TextView富文本深入探索](https://www.jianshu.com/p/aa53ee98d954)<br/>
[不可不知的开发技巧之View.Post()](https://www.jianshu.com/p/b1d5e31e2011)<br/>
[【Android Drawable】一、Drawable 类](https://www.jianshu.com/p/7cd60ffebd64)
